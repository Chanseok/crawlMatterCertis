import React from 'react';
import { useStore } from '@nanostores/react';
import { configStore, concurrentTasksStore, crawlingProgressStore, crawlingStatusStore, crawlingStatusSummaryStore, statusStore } from '../stores';
import { usePageProgressCalculation } from '../hooks/usePageProgressCalculation';
import { debugLog } from '../utils/logger';

// React.memo를 사용하여 불필요한 리렌더링 방지
export const PageProgressDisplay: React.FC = React.memo(() => {
  const tasks = useStore(concurrentTasksStore);
  const progress = useStore(crawlingProgressStore);
  const crawlingStatus = useStore(crawlingStatusStore);
  const statusSummary = useStore(crawlingStatusSummaryStore);
  const config = useStore(configStore); // pageRangeLimit 접근용
  const status = useStore(statusStore); // targetPageCount 접근용
  
  // 로깅 추가 - 상태 확인용 (개발 환경에서만 출력)
  React.useEffect(() => {
    debugLog('PageProgressDisplay 렌더링:', { 
      tasksCount: tasks.length,
      successTasks: tasks.filter(task => task.status === 'success').length,
      stage1PageStatusesCount: progress.stage1PageStatuses?.length ?? 0,
      successStage1Pages: progress.stage1PageStatuses?.filter(p => p.status === 'success').length ?? 0,
      currentPage: progress.currentPage,
      targetPageCount: status.targetPageCount
    });
  }, [tasks, progress.stage1PageStatuses, progress.currentPage, status.targetPageCount]);
  
  // 커스텀 훅을 사용하여 계산 로직 분리
  const { displaySuccessPages, displayTotalPages } = usePageProgressCalculation(
    progress, tasks, statusSummary, config, status, crawlingStatus
  );
  
  // 성공한 페이지 수 계산 (status가 'success'인 페이지 수)
  const successTaskPages = tasks.filter(task => task.status === 'success').length;
  
  // 페이지 수 계산 로직 - 항상 최대값을 사용하는 방식으로 개선
  let displaySuccessPages = 0;
  let successSourceUsed = '';
  
  // 모든 소스에서 가장 높은 성공 페이지 수를 사용
  // 1. stage1PageStatuses에서 성공 상태인 페이지 수 확인 (가장 신뢰할 수 있는 소스)
  if (progress.stage1PageStatuses && Array.isArray(progress.stage1PageStatuses) && 
      progress.stage1PageStatuses.length > 0) {
    const successStatusPages = progress.stage1PageStatuses.filter(p => p.status === 'success').length;
    if (successStatusPages > displaySuccessPages) {
      displaySuccessPages = successStatusPages;
      successSourceUsed = 'stage1PageStatuses';
    }
  }
  
  // 2. 성공한 태스크 수 확인 (실시간 업데이트에 가장 민감한 소스)
  if (successTaskPages > displaySuccessPages) {
    displaySuccessPages = successTaskPages;
    successSourceUsed = 'tasks';
  }
  
  // 3. currentPage 값 확인 (이전 버전과의 호환성)
  if (progress.currentPage !== undefined && progress.currentPage > 0 && progress.currentPage > displaySuccessPages) {
    displaySuccessPages = progress.currentPage;
    successSourceUsed = 'currentPage';
  }
  
  // 로그 남기기 (디버깅용)
  console.log('Success page count sources:', {
    fromStage1PageStatuses: progress.stage1PageStatuses?.filter(p => p.status === 'success').length || 0,
    fromTasks: successTaskPages,
    fromCurrentPage: progress.currentPage || 0,
    finalValue: displaySuccessPages,
    sourceUsed: successSourceUsed
  });
  
  // 크롤링 범위 계산 (statusSummary에 있는 경우)
  const crawlingRange = statusSummary?.crawlingRange;
  const calculatedPageCount = crawlingRange ? (crawlingRange.startPage - crawlingRange.endPage + 1) : 0;
  
  // 콘솔 로그 추가 - 계산된 값 확인용
  console.log('PageProgressDisplay - 계산된 페이지 값:', {
    crawlingRange,
    calculatedPageCount,
    statusTargetPageCount: status.targetPageCount,
    configPageRangeLimit: config.pageRangeLimit
  });
  
  // 기본값으로 계산된 페이지 범위, statusStore의 targetPageCount, 또는 config의 pageRangeLimit 사용
  let displayTotalPages: number | string = 
    (progress.currentStage === 1 && statusSummary?.actualTargetPageCountForStage1) || // 1단계일때 실제 크롤링 대상 페이지 사용
    calculatedPageCount || 
    status.targetPageCount || 
    config.pageRangeLimit || 
    '-';
  
  // 크롤링 상태에 따른 표시 설정
  // 1단계 제품 정보 수집 단계에서는 사용자가 설정한 수집 대상 페이지 범위를 우선적으로 표시
  if (
    (crawlingStatus === 'running' && progress.currentStage === 1) || 
    crawlingStatus === 'completed_stage_1'
  ) {
    // 계산된 페이지 수가 있으면 우선 사용
    if (calculatedPageCount && calculatedPageCount > 0) {
      displayTotalPages = calculatedPageCount;
    }
    // 상태 저장소에서 targetPageCount를 다음으로 사용
    else if (status.targetPageCount && status.targetPageCount > 0) {
      displayTotalPages = status.targetPageCount;
    }
    // 사용자가 설정한 페이지 범위 제한을 다음으로 사용
    else if (config.pageRangeLimit && config.pageRangeLimit > 0) {
      displayTotalPages = config.pageRangeLimit;
    }
    // progress.totalPages 값을 사용 (API에서 보고된 실제 총 페이지 수)
    else if (progress.totalPages && progress.totalPages > 0) {
      displayTotalPages = progress.totalPages;
    }
    // 상태 요약 정보가 있는 경우 (상태 체크 후)
    else if (statusSummary && statusSummary.siteTotalPages > 0) {
      displayTotalPages = statusSummary.siteTotalPages;
    }
    // 마지막 대안으로 기본값 1 사용
    else {
      displayTotalPages = 1;
    }
  } 
  // 기타 크롤링 상태 (예: 2단계 진행 중, 전체 완료 등)에서는 기존 로직을 따릅니다.
  else if (crawlingStatus === 'running' || crawlingStatus === 'completed') {
    // 상태 저장소에서 targetPageCount 사용 (상태 체크 버튼 클릭 시 설정됨)
    if (statusSummary?.actualTargetPageCountForStage1 && progress.currentStage === 1) { // 1단계일때 실제 크롤링 대상 페이지 사용
      displayTotalPages = statusSummary.actualTargetPageCountForStage1;
    } else if (status.targetPageCount && status.targetPageCount > 0) {
      displayTotalPages = status.targetPageCount;
    }
    // 상태 요약 정보가 있는 경우 (상태 체크 후)
    else if (statusSummary && statusSummary.siteTotalPages > 0) {
      // 진행 상황의 총 페이지 수
      displayTotalPages = statusSummary.siteTotalPages;
    } 
    // 진행 정보에 totalPages가 있는 경우
    else if (progress.totalPages && progress.totalPages > 0) {
      displayTotalPages = progress.totalPages;
    }
    // tasks 배열에 크롤링할 페이지가 있는 경우 (기존 fallback)
    else if (tasks.length > 0) {
      displayTotalPages = tasks.length;
    }
  }
  
  return (
    <div className="flex justify-between items-center mb-2">
      <span className="text-sm text-gray-600 dark:text-gray-400">페이지 진행 상황:</span>
      <span className="text-sm font-medium text-blue-600 dark:text-blue-400">
        {displaySuccessPages} / {displayTotalPages} 페이지
      </span>
    </div>
  );
};

export default PageProgressDisplay;
