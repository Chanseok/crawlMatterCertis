/**
 * DatabaseStore.ts
 * Domain Store for Database Operations
 * 
 * Manages database operations, product management, and database summary information.
 * Encapsulates all database-related business logic and state.
 */

import { atom } from 'nanostores';
import type { DatabaseSummary, MatterProduct } from '../../../../types';
import { getPlatformApi } from '../../platform/api';

export interface ProductDetail {
  id: string;
  productName: string;
  companyName: string;
  certNumber: string;
  lastUpdated?: string;
  [key: string]: any;
}

/**
 * Database Domain Store
 * Manages all database-related state and operations
 */
export class DatabaseStore {
  // State atoms
  public readonly summary = atom<DatabaseSummary | null>(null);
  public readonly products = atom<MatterProduct[]>([]);
  public readonly loading = atom<boolean>(false);
  public readonly saving = atom<boolean>(false);
  public readonly lastSaveResult = atom<{ success: boolean; message?: string } | null>(null);

  // Search and pagination state
  public readonly searchQuery = atom<string>('');
  public readonly currentPage = atom<number>(1);
  public readonly totalPages = atom<number>(0);

  // Unsubscribe functions
  private unsubscribeFunctions: (() => void)[] = [];
  private api = getPlatformApi();

  constructor() {
    this.initializeEventSubscriptions();
  }

  /**
   * Initialize IPC event subscriptions for database events
   */
  private initializeEventSubscriptions(): void {
    // Database summary updates
    const unsubSummary = this.api.onDatabaseSummaryUpdated((summary) => {
      this.summary.set(summary);
    });

    // Product list updates
    const unsubProducts = this.api.onProductsUpdated((products) => {
      this.products.set(products);
    });

    // Database save events
    const unsubSaveStart = this.api.onDatabaseSaveStarted(() => {
      this.saving.set(true);
      this.lastSaveResult.set(null);
    });

    const unsubSaveComplete = this.api.onDatabaseSaveCompleted((result) => {
      this.saving.set(false);
      this.lastSaveResult.set(result);
    });

    // Store unsubscribe functions
    this.unsubscribeFunctions.push(
      unsubSummary,
      unsubProducts,
      unsubSaveStart,
      unsubSaveComplete
    );
  }

  /**
   * Load database summary
   */
  async loadSummary(): Promise<DatabaseSummary | null> {
    try {
      this.loading.set(true);
      const summary = await this.api.getDatabaseSummary();
      this.summary.set(summary);
      return summary;
    } catch (error) {
      console.error('Error loading database summary:', error);
      return null;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Load products with pagination and search
   */
  async loadProducts(page: number = 1, query: string = ''): Promise<MatterProduct[]> {
    try {
      this.loading.set(true);
      this.currentPage.set(page);
      this.searchQuery.set(query);

      const result = await this.api.getProducts(page, query);
      this.products.set(result.products);
      this.totalPages.set(result.totalPages);
      
      return result.products;
    } catch (error) {
      console.error('Error loading products:', error);
      this.products.set([]);
      return [];
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Save products to database
   */
  async saveProducts(products: MatterProduct[]): Promise<{ success: boolean; message?: string }> {
    try {
      this.saving.set(true);
      this.lastSaveResult.set(null);

      const result = await this.api.saveProducts(products);
      this.lastSaveResult.set(result);
      
      // Refresh summary after successful save
      if (result.success) {
        await this.loadSummary();
      }

      return result;
    } catch (error) {
      const errorResult = { success: false, message: error instanceof Error ? error.message : 'Unknown error' };
      this.lastSaveResult.set(errorResult);
      return errorResult;
    } finally {
      this.saving.set(false);
    }
  }

  /**
   * Save specific product
   */
  async saveProduct(product: MatterProduct): Promise<{ success: boolean; message?: string }> {
    try {
      this.saving.set(true);
      this.lastSaveResult.set(null);

      const result = await this.api.saveProduct(product);
      this.lastSaveResult.set(result);

      // Refresh products list if successful
      if (result.success) {
        await this.loadProducts(this.currentPage.get(), this.searchQuery.get());
        await this.loadSummary();
      }

      return result;
    } catch (error) {
      const errorResult = { success: false, message: error instanceof Error ? error.message : 'Unknown error' };
      this.lastSaveResult.set(errorResult);
      return errorResult;
    } finally {
      this.saving.set(false);
    }
  }

  /**
   * Delete product from database
   */
  async deleteProduct(productId: string): Promise<{ success: boolean; message?: string }> {
    try {
      this.saving.set(true);
      const result = await this.api.deleteProduct(productId);
      
      // Refresh products list if successful
      if (result.success) {
        await this.loadProducts(this.currentPage.get(), this.searchQuery.get());
        await this.loadSummary();
      }

      return result;
    } catch (error) {
      return { success: false, message: error instanceof Error ? error.message : 'Unknown error' };
    } finally {
      this.saving.set(false);
    }
  }

  /**
   * Search products
   */
  async searchProducts(query: string): Promise<MatterProduct[]> {
    return this.loadProducts(1, query);
  }

  /**
   * Get product by ID
   */
  async getProduct(productId: string): Promise<MatterProduct | null> {
    try {
      return await this.api.getProduct(productId);
    } catch (error) {
      console.error('Error getting product:', error);
      return null;
    }
  }

  /**
   * Clear database
   */
  async clearDatabase(): Promise<{ success: boolean; message?: string }> {
    try {
      this.saving.set(true);
      const result = await this.api.clearDatabase();
      
      // Refresh all data if successful
      if (result.success) {
        this.products.set([]);
        this.summary.set(null);
        await this.loadSummary();
      }

      return result;
    } catch (error) {
      return { success: false, message: error instanceof Error ? error.message : 'Unknown error' };
    } finally {
      this.saving.set(false);
    }
  }

  /**
   * Refresh all data
   */
  async refresh(): Promise<void> {
    await Promise.all([
      this.loadSummary(),
      this.loadProducts(this.currentPage.get(), this.searchQuery.get())
    ]);
  }

  /**
   * Cleanup subscriptions
   */
  destroy(): void {
    this.unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
    this.unsubscribeFunctions = [];
  }

  /**
   * Get current state snapshot for debugging
   */
  getDebugInfo() {
    return {
      summary: this.summary.get(),
      productsCount: this.products.get().length,
      currentPage: this.currentPage.get(),
      totalPages: this.totalPages.get(),
      searchQuery: this.searchQuery.get(),
      loading: this.loading.get(),
      saving: this.saving.get(),
      lastSaveResult: this.lastSaveResult.get(),
      subscriptionsCount: this.unsubscribeFunctions.length
    };
  }
}

// Singleton instance and exports
export const databaseStore = new DatabaseStore();
