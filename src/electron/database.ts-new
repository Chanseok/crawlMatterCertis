import sqlite3 from 'sqlite3';
import path from 'path';
import fs from 'fs';
import { app } from 'electron';
import type { ProductDetail } from '../ui/types.js'; // Import UI-specific ProductDetail type
import type { MatterProduct, Product, DatabaseSummary } from '../../types.js'; // Import global types
import log, { debugLog as electronDebugLog } from './logger.js';
import { hexIdToInteger, hexIdListToJsonArray } from './utils/hexUtils.js';

const dbPath = path.join(app.getPath('userData'), 'dev-database.sqlite');
const db = new sqlite3.Database(dbPath);
const debugLog = electronDebugLog;


// --- Initialization --- 

export async function initializeDatabase(): Promise<void> {
    return new Promise((resolve, reject) => {
        // SQLite 데이터베이스 파일 경로 로깅
        log.info(`Initializing database at: ${dbPath}`);

        db.serialize(() => {
            // 'products' 테이블 생성
            db.run(`
                 CREATE TABLE IF NOT EXISTS products (
                    url TEXT PRIMARY KEY,
                    manufacturer TEXT,
                    model TEXT,
                    certificateId TEXT,
                    pageId INTEGER,
                    indexInPage INTEGER
                )
                `, (err) => {
                if (err) return reject(err);
                log.info("'products' table checked/created.");
            });

            // 'product_details' 테이블 생성
            db.run(`
                CREATE TABLE IF NOT EXISTS product_details (
                    url TEXT PRIMARY KEY,
                    pageId INTEGER,
                    indexInPage INTEGER,
                    id TEXT,
                    manufacturer TEXT,
                    model TEXT,
                    deviceType TEXT,
                    certificationId TEXT,
                    certificationDate TEXT,
                    softwareVersion TEXT,
                    hardwareVersion TEXT,
                    vid INTEGER,
                    pid INTEGER,
                    familySku TEXT,
                    familyVariantSku TEXT,
                    firmwareVersion TEXT,
                    familyId TEXT,
                    tisTrpTested TEXT,
                    specificationVersion TEXT,
                    transportInterface TEXT,
                    primaryDeviceTypeId TEXT,
                    applicationCategories TEXT
                )
                `, (err) => {
                if (err) return reject(err);
                log.info("'product_details' table checked/created.");
            });

            // 'vendors' 테이블 생성
            db.run(`
                CREATE TABLE IF NOT EXISTS vendors (
                    vendorId INTEGER PRIMARY KEY,
                    vendorName TEXT,
                    companyLegalName TEXT
                )
                `, (err) => {
                if (err) return reject(err);
                log.info("'vendors' table checked/created.");
            });

            // Check if tables are empty 
            db.get("SELECT COUNT(*) as count FROM products", async (err, row: { count: number }) => {
                if (err) return reject(err);
                if (row.count === 0) {
                    log.info(" EMPTY 'products' table...");

                }
                db.get("SELECT COUNT(*) as count FROM product_details", async (err, rowDetails: { count: number }) => {
                    if (err) return reject(err);
                    if (rowDetails.count === 0) {
                        log.info("EMPTY 'product_details' table...");
                    }

                    // Check if vendors table is empty
                    db.get("SELECT COUNT(*) as count FROM vendors", async (err, vendorsRow: { count: number }) => {
                        if (err) return reject(err);
                        if (vendorsRow.count === 0) {
                            log.info("EMPTY 'vendors' table...");
                        }
                        resolve(); // Resolve after checks are done
                    });
                });
            });
        });
    });
}

/**
 * Database summary data structure - internal use
 */
interface DbSummaryData {
    lastUpdated: string | null;
    newlyAddedCount: number;
}

/**
 * 데이터베이스 요약 정보 파일 경로
 */
const dbSummaryFile = path.join(app.getPath('userData'), 'db-summary.json');

/**
 * 데이터베이스 요약 정보 읽기
 * @returns DbSummaryData 객체
 */
async function readSummary(): Promise<DbSummaryData> {
    return new Promise((resolve) => {
        fs.readFile(dbSummaryFile, 'utf8', (err, data) => {
            if (err) {
                // 파일이 없거나 오류가 발생하면 기본값 반환
                return resolve({ lastUpdated: null, newlyAddedCount: 0 });
            }
            
            try {
                const summaryData = JSON.parse(data);
                return resolve(summaryData);
            } catch (e) {
                // JSON 파싱 오류시 기본값 반환
                log.error('Summary data parsing error:', e);
                return resolve({ lastUpdated: null, newlyAddedCount: 0 });
            }
        });
    });
}

/**
 * 데이터베이스 요약 정보 쓰기
 * @param summary 저장할 DbSummaryData 객체
 */
async function writeSummary(summary: DbSummaryData): Promise<void> {
    return new Promise((resolve, reject) => {
        const data = JSON.stringify(summary, null, 2);
        fs.writeFile(dbSummaryFile, data, 'utf8', (err) => {
            if (err) {
                log.error('Failed to write summary data:', err);
                return reject(err);
            }
            log.info('Summary data saved successfully');
            resolve();
        });
    });
}

/**
 * 데이터베이스 요약 정보 조회
 * @returns DatabaseSummary 객체
 */
export async function getDatabaseSummaryFromDb(): Promise<DatabaseSummary> {
    return new Promise((resolve, reject) => {
        const countQuery = `SELECT COUNT(*) as total FROM products`;
        db.get(countQuery, async (err, row: { total: number }) => {
            if (err) {
                return reject(err);
            }
            const summaryData = await readSummary();
            
            // Get the max pageId from the database
            try {
                const maxPageId = await getMaxPageIdFromDb();
                resolve({
                    totalProducts: row.total,
                    productCount: row.total, // 'productCount'를 'totalProducts'와 동일한 값으로 추가
                    lastUpdated: summaryData.lastUpdated ? new Date(summaryData.lastUpdated) : null,
                    newlyAddedCount: summaryData.newlyAddedCount,
                    lastPageId: maxPageId // Add the last page ID to the summary
                });
            } catch (maxPageIdError) {
                log.warn('Failed to get max pageId for database summary:', maxPageIdError);
                resolve({
                    totalProducts: row.total,
                    productCount: row.total,
                    lastUpdated: summaryData.lastUpdated ? new Date(summaryData.lastUpdated) : null,
                    newlyAddedCount: summaryData.newlyAddedCount,
                    lastPageId: 0 // Fallback to 0 if we can't get the max pageId
                });
            }
        });
    });
}

/**
 * 마지막 업데이트 정보 저장 (신규 추가된 경우)
 * @param count 추가된 레코드 수
 */
export async function markLastUpdatedInDb(count: number): Promise<void> {
    const summaryData: DbSummaryData = {
        lastUpdated: new Date().toISOString(),
        newlyAddedCount: count
    };
    await writeSummary(summaryData);
}

/**
 * 페이지 범위에 해당하는 제품 레코드 삭제
 * @param startPageId 시작 페이지 ID (포함)
 * @param endPageId 종료 페이지 ID (포함)
 * @returns 삭제된 레코드 수
 */
export async function deleteProductsByPageRange(startPageId: number, endPageId: number): Promise<number> {
    return new Promise((resolve, reject) => {
        log.info(`[DB] 페이지 범위 삭제 시작 - 시작 페이지: ${startPageId}, 종료 페이지: ${endPageId}`);

        // 시작 페이지가 종료 페이지보다 크거나 같은지 확인 (SQL 쿼리 조건이 반대이므로 주의)
        if (startPageId < endPageId) {
            const errorMsg = `[DB] 오류: 시작 페이지 ID(${startPageId})가 종료 페이지 ID(${endPageId})보다 작습니다.`;
            log.error(errorMsg);
            return reject(new Error(errorMsg));
        }

        // 삭제 전 레코드 개수 확인 (디버깅용)
        db.get(`SELECT COUNT(*) as count FROM products WHERE pageId >= ? AND pageId <= ?`, 
               [endPageId, startPageId], 
               (err, row: { count: number }) => {
            if (err) {
                log.error('[DB] 삭제 전 레코드 개수 확인 실패:', err);
                return reject(err);
            }
            
            log.info(`[DB] 삭제 대상 레코드 개수: ${row.count}`);
                
            // 레코드가 없는 경우 조기 리턴
            if (row.count === 0) {
                log.warn(`[DB] 경고: 페이지 범위 ${endPageId}~${startPageId}에 삭제할 레코드가 없습니다.`);
                return resolve(0); // 삭제할 레코드가 없으므로 0 반환
            }
                
            // 마지막 한 페이지 남은 경우 특별 로깅
            if (startPageId === endPageId) {
                log.info(`[DB] 마지막 한 페이지(${startPageId}) 삭제 시도 - 예상 레코드 수: ${row.count}`);
                
                // 삭제할 페이지 ID에 실제 데이터가 있는지 확인
                db.all(`SELECT * FROM products WHERE pageId = ?`, [startPageId], (err, rows) => {
                    if (err) {
                        log.error(`[DB] 페이지 ID ${startPageId}의 제품 조회 실패:`, err);
                    } else {
                        log.info(`[DB] 페이지 ID ${startPageId}의 제품 개수: ${rows.length}`);
                        if (rows.length === 0) {
                            log.warn(`[DB] 경고: 페이지 ID ${startPageId}에 제품이 없습니다.`);
                        } else {
                            log.info(`[DB] 페이지 ID ${startPageId}의 첫 번째 제품:`, JSON.stringify(rows[0]));
                        }
                    }
                });
            }

            // 트랜잭션 시작
            db.serialize(() => {
                db.run('BEGIN TRANSACTION', (err) => {
                    if (err) {
                        log.error('[DB] 트랜잭션 시작 오류:', err);
                        return reject(err);
                    }

                    log.info(`[DB] 삭제 쿼리 실행: DELETE FROM products WHERE pageId >= ${endPageId} AND pageId <= ${startPageId}`);
                    
                    // products 테이블에서 삭제
                    db.run(
                        `DELETE FROM products WHERE pageId >= ? AND pageId <= ?`, 
                        [endPageId, startPageId], 
                        function(err) {
                            if (err) {
                                log.error('[DB] products 테이블 삭제 실패:', err);
                                db.run('ROLLBACK', () => reject(err));
                                return;
                            }
                            
                            const productsDeleted = this.changes;
                            log.info(`[DB] products 테이블에서 ${productsDeleted}개 레코드 삭제됨`);
                            
                            // product_details 테이블에서도 삭제
                            db.run(
                                `DELETE FROM product_details WHERE pageId >= ? AND pageId <= ?`, 
                                [endPageId, startPageId], 
                                function(err) {
                                    if (err) {
                                        log.error('[DB] product_details 테이블 삭제 실패:', err);
                                        db.run('ROLLBACK', () => reject(err));
                                        return;
                                    }

                                    const detailsDeleted = this.changes;
                                    log.info(`[DB] product_details 테이블에서 ${detailsDeleted}개 레코드 삭제됨`);
                                    
                                    // 트랜잭션 커밋
                                    db.run('COMMIT', (err) => {
                                        if (err) {
                                            log.error('[DB] 트랜잭션 커밋 실패:', err);
                                            db.run('ROLLBACK', () => reject(err));
                                            return;
                                        }
                                        
                                        log.info(`[DB] 삭제 트랜잭션 성공적으로 커밋됨, 총 ${productsDeleted}개 레코드 삭제`);
                                        
                                        // 삭제 후 레코드 개수 확인 (디버깅용)
                                        db.get(`SELECT COUNT(*) as count FROM products`, [], (err, row: { count: number }) => {
                                            if (err) {
                                                log.error('[DB] 삭제 후 전체 레코드 개수 확인 실패:', err);
                                            } else {
                                                log.info(`[DB] 삭제 후 남은 전체 레코드 개수: ${row.count}`);
                                            }
                                        });
                                        
                                        // 삭제된 총 레코드 수 반환
                                        resolve(productsDeleted);
                                    });
                                }
                            );
                        }
                    );
                });
            });
        });
    });
}

/**
 * 데이터베이스에서 가장 큰 pageId 값을 조회
 * @returns 가장 큰 pageId 값
 */
export async function getMaxPageIdFromDb(): Promise<number> {
    return new Promise((resolve, reject) => {
        db.get(`SELECT MAX(pageId) as maxPageId FROM products`, (err, row: { maxPageId: number | null }) => {
            if (err) {
                return reject(err);
            }
            // maxPageId가 null인 경우(테이블이 비어있는 경우) 0 반환
            const maxPageId = row.maxPageId !== null ? row.maxPageId : 0;
            log.info(`현재 최대 pageId: ${maxPageId}`);
            resolve(maxPageId);
        });
    });
}
