// Test file with just the deleteProductsByPageRange function
import sqlite3 from 'sqlite3';
import path from 'path';
import { app } from 'electron';
import type { MatterProduct, DatabaseSummary } from '../../types.js';
import log from './logger.js';

const dbPath = path.join(app.getPath('userData'), 'dev-database.sqlite');
const db = new sqlite3.Database(dbPath);

/**
 * 페이지 범위에 해당하는 제품 레코드 삭제
 * @param startPageId 시작 페이지 ID (포함)
 * @param endPageId 종료 페이지 ID (포함)
 * @returns 삭제된 레코드 수
 */
export async function deleteProductsByPageRange(startPageId: number, endPageId: number): Promise<number> {
    return new Promise((resolve, reject) => {
        log.info(`[DB] 페이지 범위 삭제 시작 - 시작 페이지: ${startPageId}, 종료 페이지: ${endPageId}`);

        // 시작 페이지가 종료 페이지보다 크거나 같은지 확인 (SQL 쿼리 조건이 반대이므로 주의)
        if (startPageId < endPageId) {
            const errorMsg = `[DB] 오류: 시작 페이지 ID(${startPageId})가 종료 페이지 ID(${endPageId})보다 작습니다.`;
            log.error(errorMsg);
            return reject(new Error(errorMsg));
        }

        // 삭제 전 레코드 개수 확인 (디버깅용)
        db.get(`SELECT COUNT(*) as count FROM products WHERE pageId >= ? AND pageId <= ?`, 
               [endPageId, startPageId], 
               (err, row: { count: number }) => {
            if (err) {
                log.error('[DB] 삭제 전 레코드 개수 확인 실패:', err);
                return reject(err);
            } else {
                log.info(`[DB] 삭제 대상 레코드 개수: ${row.count}`);
                
                // 레코드가 없는 경우 조기 리턴
                if (row.count === 0) {
                    log.warn(`[DB] 경고: 페이지 범위 ${endPageId}~${startPageId}에 삭제할 레코드가 없습니다.`);
                    return resolve(0); // 삭제할 레코드가 없으므로 0 반환
                }
                
                // 마지막 한 페이지 남은 경우 특별 로깅
                if (startPageId === endPageId) {
                    log.info(`[DB] 마지막 한 페이지(${startPageId}) 삭제 시도 - 예상 레코드 수: ${row.count}`);
                    
                    // 삭제할 페이지 ID에 실제 데이터가 있는지 확인
                    db.all(`SELECT * FROM products WHERE pageId = ?`, [startPageId], (err, rows) => {
                        if (err) {
                            log.error(`[DB] 페이지 ID ${startPageId}의 제품 조회 실패:`, err);
                        } else {
                            log.info(`[DB] 페이지 ID ${startPageId}의 제품 개수: ${rows.length}`);
                            if (rows.length === 0) {
                                log.warn(`[DB] 경고: 페이지 ID ${startPageId}에 제품이 없습니다.`);
                            } else {
                                log.info(`[DB] 페이지 ID ${startPageId}의 첫 번째 제품:`, JSON.stringify(rows[0]));
                            }
                        }
                    });
                }
            }

            // 트랜잭션 시작
            db.serialize(() => {
                db.run('BEGIN TRANSACTION', (err) => {
                    if (err) {
                        log.error('[DB] 트랜잭션 시작 오류:', err);
                        return reject(err);
                    }

                    log.info(`[DB] 삭제 쿼리 실행: DELETE FROM products WHERE pageId >= ${endPageId} AND pageId <= ${startPageId}`);
                    
                    // products 테이블에서 삭제
                    db.run(
                        `DELETE FROM products WHERE pageId >= ? AND pageId <= ?`, 
                        [endPageId, startPageId], 
                        function(err) {
                            if (err) {
                                log.error('[DB] products 테이블 삭제 실패:', err);
                                db.run('ROLLBACK', () => reject(err));
                                return;
                            }
                            
                            const productsDeleted = this.changes;
                            log.info(`[DB] products 테이블에서 ${productsDeleted}개 레코드 삭제됨`);
                            
                            // product_details 테이블에서도 삭제
                            db.run(
                                `DELETE FROM product_details WHERE pageId >= ? AND pageId <= ?`, 
                                [endPageId, startPageId], 
                                function(err) {
                                    if (err) {
                                        log.error('[DB] product_details 테이블 삭제 실패:', err);
                                        db.run('ROLLBACK', () => reject(err));
                                        return;
                                    }

                                    const detailsDeleted = this.changes;
                                    log.info(`[DB] product_details 테이블에서 ${detailsDeleted}개 레코드 삭제됨`);
                                    
                                    // 트랜잭션 커밋
                                    db.run('COMMIT', (err) => {
                                        if (err) {
                                            log.error('[DB] 트랜잭션 커밋 실패:', err);
                                            db.run('ROLLBACK', () => reject(err));
                                            return;
                                        }
                                        
                                        log.info(`[DB] 삭제 트랜잭션 성공적으로 커밋됨, 총 ${productsDeleted}개 레코드 삭제`);
                                        
                                        // 삭제 후 레코드 개수 확인 (디버깅용)
                                        db.get(`SELECT COUNT(*) as count FROM products`, [], (err, row: { count: number }) => {
                                            if (err) {
                                                log.error('[DB] 삭제 후 전체 레코드 개수 확인 실패:', err);
                                            } else {
                                                log.info(`[DB] 삭제 후 남은 전체 레코드 개수: ${row.count}`);
                                            }
                                        });
                                        
                                        // 삭제된 총 레코드 수 반환
                                        resolve(productsDeleted);
                                    });
                                }
                            );
                        }
                    );
                });
            });
        });
    });
}

/**
 * 데이터베이스에서 가장 큰 pageId 값을 조회
 * @returns 가장 큰 pageId 값
 */
export async function getMaxPageIdFromDb(): Promise<number> {
    return new Promise((resolve, reject) => {
        db.get(`SELECT MAX(pageId) as maxPageId FROM products`, (err, row: { maxPageId: number | null }) => {
            if (err) {
                return reject(err);
            }
            // maxPageId가 null인 경우(테이블이 비어있는 경우) 0 반환
            const maxPageId = row.maxPageId !== null ? row.maxPageId : 0;
            log.info(`현재 최대 pageId: ${maxPageId}`);
            resolve(maxPageId);
        });
    });
}

export interface DbSummaryData {
    lastUpdated: string;
    newlyAddedCount: number;
}

/**
 * 데이터베이스 요약 정보 조회
 * @returns DatabaseSummary 객체
 */
export async function getDatabaseSummaryFromDb(): Promise<DatabaseSummary> {
    return new Promise((resolve, reject) => {
        const countQuery = `SELECT COUNT(*) as total FROM products`;
        db.get(countQuery, async (err, row: { total: number }) => {
            if (err) {
                return reject(err);
            }
            const summaryData = await readSummary();
            
            // Get the max pageId from the database
            try {
                const maxPageId = await getMaxPageIdFromDb();
                resolve({
                    totalProducts: row.total,
                    productCount: row.total,
                    lastUpdated: summaryData.lastUpdated ? new Date(summaryData.lastUpdated) : null,
                    newlyAddedCount: summaryData.newlyAddedCount,
                    lastPageId: maxPageId
                });
            } catch (maxPageIdError) {
                log.warn('Failed to get max pageId for database summary:', maxPageIdError);
                resolve({
                    totalProducts: row.total,
                    productCount: row.total,
                    lastUpdated: summaryData.lastUpdated ? new Date(summaryData.lastUpdated) : null,
                    newlyAddedCount: summaryData.newlyAddedCount,
                    lastPageId: 0
                });
            }
        });
    });
}

async function readSummary(): Promise<DbSummaryData> {
    return {
        lastUpdated: new Date().toISOString(),
        newlyAddedCount: 0
    };
}
